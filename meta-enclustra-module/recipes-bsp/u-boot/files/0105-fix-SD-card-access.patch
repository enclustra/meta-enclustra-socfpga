From 421bb560b1a31765474f3faa37c160f110e08df4 Mon Sep 17 00:00:00 2001
From: Andreas Buerkler <andreas.buerkler@enclustra.com>
Date: Tue, 13 Feb 2024 15:31:58 +0000
Subject: [PATCH] Fix SD card access

---
 board/enclustra/mercury_aa1/mercury_aa1.c | 73 ++++++++++++++++-------
 1 file changed, 53 insertions(+), 20 deletions(-)

diff --git a/board/enclustra/mercury_aa1/mercury_aa1.c b/board/enclustra/mercury_aa1/mercury_aa1.c
index 903413548b..4a5a237dce 100644
--- a/board/enclustra/mercury_aa1/mercury_aa1.c
+++ b/board/enclustra/mercury_aa1/mercury_aa1.c
@@ -35,6 +35,12 @@
 
 static int altera_current_storage = ALTERA_NONE;
 
+void set_gpio(int value, const char* name);
+int get_gpio(const char* name);
+
+const char* gpio_name_flash_sel = "portc6";
+const char* gpio_name_flash_oe = "portb5";
+
 #endif
 
 static struct eeprom_mem eeproms[] = {
@@ -115,11 +121,23 @@ int configure_mac(void)
 
 int board_late_init(void)
 {
+	int ret;
+
+#if !defined(CONFIG_SPL_BUILD)
+
+	// When the flash_sel GPIO is left floating, SD card access is not reliable.
+	// As workaround we set the two GPIOs in use to the read value.
+	set_gpio(get_gpio(gpio_name_flash_sel), gpio_name_flash_sel);
+	set_gpio(get_gpio(gpio_name_flash_oe), gpio_name_flash_oe);
+
 #ifdef CONFIG_SI5338_CONFIGURATION
 	si5338_init();
 #endif
-	int ret;
+
 	ret = configure_mac();
+
+#endif
+
 	return ret;
 }
 
@@ -194,58 +212,76 @@ static void set_mux_qspi (void)
 	}
 }
 
-void altera_set_storage (int store)
+void set_gpio(int value, const char* name)
 {
-	if (store == altera_current_storage)
-		return;
+	unsigned int gpio;
 
-	unsigned int gpio_flash_sel;
-	unsigned int gpio_flash_oe;
-
-	if (gpio_lookup_name("portb5", NULL, NULL, &gpio_flash_oe))
+	if (gpio_lookup_name(name, NULL, NULL, &gpio))
 	{
 		printf("ERROR: GPIO not found\n");
 		return;
 	}
 
-	if (gpio_request(gpio_flash_oe, "flash_oe"))
+	if (gpio_request(gpio, "temp_gpio"))
 	{
 		printf("ERROR: GPIO request failed\n");
 		return;
 	}
+	gpio_direction_output(gpio, value);
+	gpio_free(gpio);
+}
+
+int get_gpio(const char* name)
+{
+	unsigned int gpio;
+	int value = 0;
 
-	if (gpio_lookup_name("portc6", NULL, NULL, &gpio_flash_sel))
+	if (gpio_lookup_name(name, NULL, NULL, &gpio))
 	{
 		printf("ERROR: GPIO not found\n");
 		return;
 	}
 
-	if (gpio_request(gpio_flash_sel, "flash_sel"))
+	if (gpio_request(gpio, "temp_gpio"))
 	{
 		printf("ERROR: GPIO request failed\n");
 		return;
 	}
+	value = gpio_get_value(gpio);
+	gpio_free(gpio);
+
+	return value;
+}
+
+
+void altera_set_storage (int store)
+{
+	if (store == altera_current_storage)
+		return;
+
+	unsigned int gpio_flash_sel;
+	unsigned int gpio_flash_oe;
 
 	switch (store)
 	{
 		case ALTERA_MMC:
 			set_mux_mmc();
-			gpio_direction_output(gpio_flash_sel, 0);
-			gpio_direction_output(gpio_flash_oe, 0);
+			set_gpio(0, gpio_name_flash_sel);
+			set_gpio(0, gpio_name_flash_oe);
 			altera_current_storage = ALTERA_MMC;
 			writel(MMC_CLK_DIV, ALTERA_CLKMGR_MAINPLL_CNTR6CLK_BASE);
 			break;
 		case ALTERA_EMMC:
 			set_mux_emmc();
-			gpio_direction_output(gpio_flash_sel, 1);
-			gpio_direction_output(gpio_flash_oe, 1);
+			set_gpio(1, gpio_name_flash_sel);
+			set_gpio(1, gpio_name_flash_oe);
 			altera_current_storage = ALTERA_EMMC;
 			writel(MMC_CLK_DIV, ALTERA_CLKMGR_MAINPLL_CNTR6CLK_BASE);
 			break;
 		case ALTERA_QSPI:
 			set_mux_qspi();
-			gpio_direction_output(gpio_flash_sel, 1);
-			gpio_direction_output(gpio_flash_oe, 0);
+			set_gpio(1, gpio_name_flash_sel);
+			set_gpio(0, gpio_name_flash_oe);
 			altera_current_storage = ALTERA_QSPI;
 			writel(QSPI_CLK_DIV, ALTERA_CLKMGR_MAINPLL_CNTR6CLK_BASE );
 			break;
@@ -253,9 +289,6 @@ void altera_set_storage (int store)
 			altera_current_storage = ALTERA_NONE;
 			break;
 	}
-
-	gpio_free(gpio_flash_sel);
-	gpio_free(gpio_flash_oe);
 }
 
 int altera_set_storage_cmd(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
-- 
2.34.1

